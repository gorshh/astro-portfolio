---
import { getLangFromUrl, useTranslations } from "../../i18n/utils";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
---

<div id="canvas" class="content__text" data-greeting={t("hero.greeting")}>
  <span class="content__text-inner"></span>
</div>

<style>
  #canvas {
    transition: ease-in-out 0.5s;
    z-index: 2;
    display: flex;
    justify-content: center;
    align-items: center;
    height: calc(100dvh - 100px);
    overflow: hidden;

    .b-canvas {
      filter: invert(100%);
    }

    .b-canvas.hide {
      display: none;
    }
  }
</style>

<script>

  type n = number;

  document.fonts.ready.then(() => {
    const MathUtils = {
      lineEq: (y2: n, y1: n, x2: n, x1: n, val: n) =>
        ((y2 - y1) / (x2 - x1)) * val + y1,
      lerp: (a: n, b: n, n: n) => (1 - n) * a + n * b,
      distance: (x1: n, x2: n, y1: n, y2: n) => Math.hypot(x1 - x2, y1 - y2),
    };

    const alignToMultipleOf4 = (value: number) => Math.floor(value / 4) * 4;

    let winSize = {
      width: alignToMultipleOf4(window.innerWidth),
      height: alignToMultipleOf4(window.innerHeight)
    };

    const getMousePos = (event: MouseEvent) => ({
      x: event.clientX + window.scrollX,
      y: event.clientY + window.scrollY,
    });

    let mousePos = { x: winSize.width / 2, y: winSize.height / 2 };
    let lastMousePosition = { ...mousePos };
    let volatility = 0;

    window.addEventListener("mousemove", (event) => {
      mousePos = getMousePos(event);
    });

    const elem = document.querySelector(".content__text")!;
    const textEl = elem.querySelector("span.content__text-inner")!;

    const settings = [
      {
        minWidth: 0,
        maxWidth: 768,
        fontSize: 60,
        paddingLeft: 100,
        paddingRight: 100,
        paddingTop: 60,
        paddingBottom: 60,
      },
      {
        minWidth: 769,
        maxWidth: Infinity,
        fontSize: 120,
        paddingLeft: 430,
        paddingRight: 430,
        paddingTop: 150,
        paddingBottom: 150,
      },
    ];

    const getCurrentSettings = (width: number) => {
      return settings.find(
        (s) => width >= s.minWidth && width <= s.maxWidth
      )!;
    };

    let currentSettings = getCurrentSettings(winSize.width);
    let blotterScope: any = null;

    const createBlotterText = (textParam: string, config: typeof currentSettings) => {
      if (blotterScope && blotterScope.domElement && blotterScope.domElement.parentNode) {
        blotterScope.domElement.parentNode.removeChild(blotterScope.domElement);
      }

      const text = new Blotter.Text(textParam, {
        family: "'WienModern'",
        weight: 800,
        size: config.fontSize,
        paddingLeft: config.paddingLeft,
        paddingRight: config.paddingRight,
        paddingTop: config.paddingTop,
        paddingBottom: config.paddingBottom,
        fill: "#181818",
      });

      const material = new Blotter.ChannelLiquidMaterial();
      material.uniforms.uSpeed.value = 0.3;
      material.uniforms.uVolatility.value = 0;
      material.uniforms.uSeed.value = 1;

      const blotter = new Blotter(material, { texts: text });
      blotterScope = blotter.forText(text);
      blotterScope.appendTo(elem);

      const render = () => {
        const relMousePos = { x: mousePos.x, y: mousePos.y };
        const mouseDistance = MathUtils.distance(
          lastMousePosition.x,
          relMousePos.x,
          lastMousePosition.y,
          relMousePos.y
        );

        volatility = MathUtils.lerp(
          volatility,
          Math.min(MathUtils.lineEq(0.9, 0, 100, 0, 2 * mouseDistance), 0.9),
          0.05
        );

        material.uniforms.uVolatility.value = 0.05 + volatility;
        material.uniforms.uOffset.value =
          0.001 + Math.min(volatility / 10, 0.1);

        lastMousePosition = { ...relMousePos };
        requestAnimationFrame(render);
      };

      render();
    };

    const canvas = document.querySelector("#canvas")! as HTMLElement;
    const greeting = canvas.dataset.greeting;

    createBlotterText(greeting!, currentSettings);

    // --- Manejo de resize controlado ---

    const debounce = (func: () => void, delay = 300) => {
      let timeout: number;
      return () => {
        clearTimeout(timeout);
        timeout = setTimeout(func, delay);
      };
    };

    let lastResizeTimeout: number;

    const handleResize = debounce(() => {
      const newWinSize = {
        width: alignToMultipleOf4(window.innerWidth),
        height: alignToMultipleOf4(window.innerHeight)
      };
      const newSettings = getCurrentSettings(newWinSize.width);

      if (newSettings !== currentSettings) {
        currentSettings = newSettings;

        // Espera adicional para asegurar estabilidad antes de recrear
        if (lastResizeTimeout) clearTimeout(lastResizeTimeout);
        lastResizeTimeout = window.setTimeout(() => {
          createBlotterText(greeting!, currentSettings);
        }, 200);
      }

      winSize = newWinSize;
    }, 300);

    window.addEventListener("resize", handleResize);
  });

</script>
